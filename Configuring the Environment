# ROS 2 — Configuring the Environment (GitHub‑ready notes)

**Goal:** Prepare a ROS 2 environment so `ros2` commands, packages, overlays and nodes work correctly.

**Level:** Beginner → Intermediate

**How to use:** Save this file as `ROS2_configuring_environment.md` in a Git repository (example commands near the end). This file is already formatted for GitHub (Markdown headings, code blocks, and short examples).

---

## Table of contents

1. [Background (short)](#background-short)
2. [Quick checklist](#quick-checklist)
3. \[Commands & explanations — child story + formal notes]

   * [source /opt/ros/<distro>/setup.bash](#source)
   * [echo "source ..." >> \~/.bashrc (persisting)](#persist)
   * [printenv | grep -i ROS (inspect env)](#inspect)
   * [export ROS\_DOMAIN\_ID=<id> (domain isolation)](#domain)
   * [export ROS\_LOCALHOST\_ONLY=1 (limit to localhost)](#localhost_only)
   * [Combining workspaces (underlay/overlay)](#workspaces)
4. [Important environment variables to know](#env_vars)
5. [Troubleshooting (common problems & fixes)](#troubleshooting)
6. [Save these notes to GitHub — step by step](#github)
7. [Short checklist / TL;DR](#tldr)

---

## Background (short)

ROS 2 exposes commands and packages by modifying your shell environment (PATH, Python paths, library paths, etc.). To use ROS 2 you *must* run the distribution’s setup file (or add it to your shell startup script) so that the right environment variables are present.

---

## Quick checklist

* Run the `setup.*` script for your shell when you open a new terminal.
* Or add the `source` command to your shell startup file (e.g., `~/.bashrc` or `~/.zshrc`).
* Verify important variables are present: `ROS_DISTRO`, `ROS_VERSION`, `ROS_PYTHON_VERSION`.
* Set `ROS_DOMAIN_ID` if you want radio-group-style isolation.
* Set `ROS_LOCALHOST_ONLY=1` to limit ROS 2 communications to the local machine.

---

## Commands & explanations — child story + formal notes

### #source

#### Child story

Imagine you have a toy robot and a treasure chest of batteries. Every time you open the toy box (a new terminal), you must put batteries into the robot before it will run. The `source` command is like putting the batteries in — it wakes up ROS 2 commands for that terminal.

#### Formal explanation

**Command syntax (Linux / macOS)**

```bash
# Bash / Zsh
source /opt/ros/humble/setup.bash
# or equivalently (dot is shorthand)
. /opt/ros/humble/setup.bash
```

**What this does:**

* `source` is a shell builtin that executes the contents of the named script *in the current shell process* (not in a child shell). That means any `export` or `PATH` changes inside the script apply to your current terminal session.
* The ROS `setup.*` script sets many environment variables (PATH, LD\_LIBRARY\_PATH, PYTHONPATH, AMENT\_PREFIX\_PATH, ROS\_DISTRO, ROS\_VERSION, etc.). These variables are what make `ros2` commands and ROS 2 packages discoverable.

**Notes & variants:**

* Replace `humble` with your ROS 2 distro name (`foxy`, `galactic`, `humble`, `iron`, etc.).
* If you built from source or installed in a custom location, the path will be different, e.g. `~/ros2_ws/install/setup.bash`.
* For `zsh` install use `setup.zsh`; for `fish` use the `setup.fish` file provided by the install.
* On Windows (cmd.exe) use the `.bat` file instead: e.g. `call C:\dev\ros2_humble\local_setup.bat`.

**Undo / temporary scope:**

* Close the terminal to discard the session-specific variables, or manually `unset` variables (not usually necessary). Example: `unset ROS_DISTRO`.

---

### #persist

#### Child story

Imagine sticking a sticky note on your bedroom door that reminds you to put batteries in the robot every time you open the door. Appending the `source` command to your shell startup file is like that sticky note — the shell will run the command automatically when you open a new terminal.

#### Formal explanation

**Command syntax**

```bash
# Append to ~/.bashrc (Bash)
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc

# For Zsh
echo "source /opt/ros/humble/setup.zsh" >> ~/.zshrc
```

**What this does:**

* `echo "..."` prints the text string.
* `>>` appends the printed text to the end of the specified file (`~/.bashrc` in this case). That means on every new shell session your setup script will be sourced automatically.

**Undo:**

* Remove the appended line manually with a text editor, or run (careful):

```bash
# Remove the exact line (GNU sed)
sed -i '/source \/opt\/ros\/humble\/setup.bash/d' ~/.bashrc
```

**Notes:**

* On macOS modern default shells use `zsh`, so prefer `~/.zshrc` or `~/.zprofile` depending on interactive vs login shells.
* If your terminal starts a login shell, check whether you must add the line to `~/.profile`, `~/.bash_profile` or `~/.zprofile`.

---

### #inspect

#### Child story

When we put batteries in the robot, we might check the battery level gauge to make sure everything is OK. `printenv | grep -i ROS` is the little gauge that shows the environment variables related to ROS.

#### Formal explanation

**Command syntax**

```bash
printenv | grep -i ROS
# or
env | grep -i ROS

# Quick check for specific variables:
echo "$ROS_DISTRO"
echo "$ROS_VERSION"
```

**What this does:**

* `printenv` (or `env`) prints environment variables for the current shell.
* The pipe `|` sends that output to `grep` which filters lines matching `ROS` (case-insensitive due to `-i`).
* This helps confirm the setup file actually set the expected variables.

**Example expected output:**

```
ROS_VERSION=2
ROS_PYTHON_VERSION=3
ROS_DISTRO=humble
```

**Pro tip:** If nothing matching `ROS` appears, the setup script was not correctly sourced for this shell.

---

### #domain

#### Child story

Think of `ROS_DOMAIN_ID` like a private walkie-talkie channel number. If your team chooses channel 42, only radios on channel 42 can hear each other — this prevents accidental mixing with other groups.

#### Formal explanation

**Command syntax**

```bash
# Set for current shell
export ROS_DOMAIN_ID=42

# Persist between sessions (append to ~/.bashrc)
echo 'export ROS_DOMAIN_ID=42' >> ~/.bashrc
```

**What this does:**

* `ROS_DOMAIN_ID` is an integer that isolates DDS/ROS 2 traffic: nodes with different domain IDs will not discover or communicate with each other.
* Useful when multiple independent ROS 2 systems share the same physical network (classrooms, labs, demos).

**Check it:**

```bash
echo "$ROS_DOMAIN_ID"
```

**Undo:**

```bash
unset ROS_DOMAIN_ID
# and remove the line from ~/.bashrc if you persisted it
```

**Windows notes:**

* In PowerShell for the current session: `$env:ROS_DOMAIN_ID = "42"`
* To persist: `setx ROS_DOMAIN_ID "42"` (but `setx` writes to the registry and requires restarting new shells to take effect).

---

### #localhost\_only

#### Child story

If you want your toy robot to only talk to toys inside your room (not the whole neighborhood), you close the window so sound can’t get out. `ROS_LOCALHOST_ONLY=1` closes the window: ROS 2 will only use localhost (127.0.0.1).

#### Formal explanation

**Command syntax**

```bash
export ROS_LOCALHOST_ONLY=1
# Persist
echo 'export ROS_LOCALHOST_ONLY=1' >> ~/.bashrc
```

**What this does:**

* When set, ROS 2 is configured to limit discovery and communication to the local host. That is, topics/services/actions will not be visible to other computers on the network.
* Very useful in shared networks (classrooms/labs) to avoid cross-talk between systems.

**Disable (allow network):**

```bash
unset ROS_LOCALHOST_ONLY
# or set it to 0 explicitly:
export ROS_LOCALHOST_ONLY=0
```

---

### #workspaces (underlay / overlay)

#### Child story

Imagine making a layered cake: the base layer (underlay) is your store-bought cake (the system ROS), and the top layers (overlays) are your decorations and frosting (your local packages). You must put the base first, then the frosting, otherwise the stack won't look right.

#### Formal explanation

**Common workflow**

1. Install system ROS (the underlay) — typically in `/opt/ros/<distro>`.
2. Create and build a workspace (overlay) with `colcon build`:

```bash
# in your workspace root
colcon build --symlink-install
```

3. Source the underlay, then the overlay. Order matters (underlay first):

```bash
# source underlay first (system ROS)
source /opt/ros/humble/setup.bash

# then source your workspace install overlay
source ~/ros2_ws/install/setup.bash
```

**Why order matters:**

* When you source an overlay's `setup.bash`, it prepends its install prefixes to `AMENT_PREFIX_PATH` (and modifies PATH, PYTHONPATH, etc.) making overlay packages take precedence over underlay packages where appropriate.

**Inspect prefixes:**

```bash
printenv | grep -E 'AMENT_PREFIX_PATH|COLCON_PREFIX_PATH'
```

**If you repeatedly use many overlays:**

* Always source the lower-level (older) ones first, then the higher-level ones.

---

## Important environment variables to know

* `ROS_DISTRO` — the ROS 2 distribution name (e.g., `humble`).
* `ROS_VERSION` — major ROS version number, usually `2`.
* `ROS_PYTHON_VERSION` — Python major version used by ROS (e.g., `3`).
* `AMENT_PREFIX_PATH` — prefixes for ament-installed packages (helps discovery).
* `COLCON_PREFIX_PATH` — similar, used when overlaying multiple colcon installs.
* `PATH` — includes `.../bin` so `ros2` CLI is found.
* `LD_LIBRARY_PATH` (Linux) — runtime library lookup paths.
* `PYTHONPATH` — Python package discovery for ROS Python packages.
* `ROS_DOMAIN_ID` — DDS domain ID for network isolation.
* `ROS_LOCALHOST_ONLY` — if `1`, restrict communication to localhost.

---

## Troubleshooting (common problems & fixes)

**Problem:** `ros2` command not found

* **Cause:** Setup file not sourced for current shell/session.
* **Fix:** Run `source /opt/ros/humble/setup.bash` (or add to `~/.bashrc`) and open a new terminal. Check `echo $PATH | grep "/opt/ros"` or `which ros2`.

**Problem:** A package cannot be found / import error for Python package

* **Cause:** Not sourcing your workspace overlay or `PYTHONPATH` missing the workspace `install` location.
* **Fix:** `source ~/ros2_ws/install/setup.bash` (after building with `colcon build`). Check `echo $PYTHONPATH`.

**Problem:** Nodes on different machines can't discover each other

* **Cause:** Mismatched `ROS_DOMAIN_ID`, `ROS_LOCALHOST_ONLY=1`, firewall, or DDS settings.
* **Fix:** Ensure both machines use same `ROS_DOMAIN_ID` (or unset it), set `ROS_LOCALHOST_ONLY=0` if you want network discovery, and check firewall/UDP rules for DDS.

**Problem:** Changes in `~/.bashrc` didn't take effect

* **Cause:** The shell you opened may be a login shell that reads `~/.profile` or `~/.bash_profile` instead.
* **Fix:** Add the source line to the right startup file for your shell, or `source ~/.bashrc` manually to reload.

**Problem:** Running a service with `sudo` loses environment

* **Cause:** `sudo` clears the environment by default.
* **Fix:** use `sudo -E` (preserve environment) or add system-wide env vars to files in `/etc/profile.d/`. Be careful with security implications.

---

## Save these notes to GitHub — step by step

You must create the GitHub repository yourself or allow the remote to be created; I cannot push to your account.

### Create a local repo and push (HTTPS example)

```bash
# inside directory where this file lives
git init
git add ROS2_configuring_environment.md
git commit -m "Add ROS 2 environment configuration notes"
# create a remote repository on GitHub first (via web UI), then:
git remote add origin https://github.com/YOUR_USERNAME/YOUR_REPO.git
git branch -M main
git push -u origin main
```

### Create a local repo and push (SSH example)

```bash
git remote add origin git@github.com:YOUR_USERNAME/YOUR_REPO.git
git push -u origin main
```

**If you prefer GitHub web UI:**

1. Create a new repository on github.com (click "New").
2. Choose a name, then upload this `ROS2_configuring_environment.md` file using the web editor or drag-and-drop.

---

## TL;DR / Short checklist

* `source /opt/ros/<distro>/setup.bash` every new shell (or add to `~/.bashrc`).
* `printenv | grep -i ROS` to verify the environment.
* Use `export ROS_DOMAIN_ID=NN` to isolate nodes on a domain.
* Use `export ROS_LOCALHOST_ONLY=1` to restrict to local machine.
* Source overlays in order: underlay first, then overlays.
* If a CLI command is missing, check `PATH` and whether setup was sourced.

---

## Final notes

* Replace `humble` with the ROS 2 distribution you're using.
* If you installed ROS 2 from source, your `setup.bash` path is likely inside your workspace: `~/ros2_ws/install/setup.bash`.
* Keep a short checklist like the TL;DR above in your dotfiles or developer notes to shorten setup time.

---

*Document created as GitHub‑friendly Markdown. If you'd like, I can also generate a downloadable `.md` file here or show you a `git` script to create the repo automatically (you will still need to authenticate to GitHub).*
